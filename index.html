<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的网页 + 纯前端对话模型（无限制）</title>
    <link rel="stylesheet" href="style.css">
    <!-- 引入 Transformers.js（纯前端运行对话模型，无需下载） -->
    <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.0"></script>
</head>
<body>
    <div class="container">
        <h1>欢迎来到我的个人网页</h1>
        <p>纯前端对话模型（完全开源、无次数限制、无需API/注册）👇</p>
        <p>可以和我聊任何话题，模型在浏览器内运行，永久免费～</p>

        <!-- 对话区域 -->
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input">
                <input type="text" id="userInput" placeholder="请输入你想聊的内容...">
                <button id="sendBtn">发送</button>
            </div>
        </div>
    </div>

    <script>
        // 获取页面元素
        const chatMessages = document.getElementById('chatMessages');
        const userInput = document.getElementById('userInput');
        const sendBtn = document.getElementById('sendBtn');

        // 初始化对话模型（DistilGPT2，轻量开源，纯前端运行）
        let generator = null;
        // 对话历史（保存上下文，让回复更连贯）
        let chatHistory = [];

        // 加载模型（首次加载稍慢，后续缓存，秒开）
        async function initChatModel() {
            addMessage('正在加载对话模型...（首次加载约10秒，后续无限制使用）', false);
            // 加载开源对话模型（DistilGPT2，体积小、适合前端）
            generator = await window.transformers.pipeline('text-generation', 'Xenova/distilgpt2');
            addMessage('模型加载完成！可以开始聊天啦～', false);
        }

        // 添加消息到对话界面
        function addMessage(content, isUser = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user-message' : 'ai-message'}`;
            messageDiv.textContent = content;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // 纯前端对话生成（无API，无次数限制，基于上下文回复）
        async function generateReply(userText) {
            try {
                // 更新对话历史（保留最近5轮，避免模型过载）
                chatHistory.push(`用户：${userText}`);
                if (chatHistory.length > 10) chatHistory.splice(0, 2); // 只保留最近5轮对话

                // 构造模型输入（包含上下文，让回复更连贯）
                const inputText = chatHistory.join('\n') + '\nAI：';

                // 模型生成回复（控制长度，避免内容过长）
                const result = await generator(inputText, {
                    max_new_tokens: 100, // 最大回复长度
                    temperature: 0.7, // 随机性（0-1，越高越灵活）
                    top_p: 0.9, // 采样策略
                    repetition_penalty: 1.2, // 避免重复回复
                    do_sample: true, // 启用采样，让回复更自然
                });

                // 提取并整理回复（去掉输入前缀，只保留AI生成的内容）
                let reply = result[0].generated_text.replace(inputText, '').trim();
                // 避免回复为空
                if (!reply) reply = '哈哈，这个话题我有点懵～ 换个话题聊聊吧！';

                // 更新对话历史
                chatHistory.push(`AI：${reply}`);
                return reply;
            } catch (error) {
                console.error('对话生成失败:', error);
                return '抱歉，我暂时没反应过来～ 再问我一次吧！';
            }
        }

        // 发送按钮点击事件
        sendBtn.addEventListener('click', async () => {
            const userText = userInput.value.trim();
            if (!userText) return;

            // 添加用户消息到界面
            addMessage(userText, true);
            userInput.value = '';

            // 添加“思考中”提示
            const loadingMsg = addMessage('正在思考中...', false);

            // 调用纯前端模型生成回复
            const aiReply = await generateReply(userText);
            
            // 替换“思考中”为真实回复
            loadingMsg.textContent = aiReply;
        });

        // 回车键触发发送
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') sendBtn.click();
        });

        // 页面加载完成后初始化模型
        window.onload = async () => {
            await initChatModel();
        };
    </script>
</body>
</html>
